# 一、什么是Promise

Promise是一个优秀的异步编程解决方案，它是一个对象，用来获取异步操作的消息。Promise具有两个重要的特点：
> 1.对象的状态不受外界的影响，有三种状态分别是：**pending**(进行中)，**fulfilled**(已成功)，**rejected**(已失败)，只有异步操作的结果才能改变其状态。
> 2.一旦状态改变，之后就不会再改变。状态改变只有**pending->fulfilled**和**pending->rejected**两种。一旦改变发生状态就凝固，即使再添加回调函数也是没有用了。

 
Promise也是有缺点的，主要是以下几点：
> 1.无法取消Promise，一旦新建它就会立即执行，无法中途取消。
> 2.如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
> 3.当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）

# 二、基本用法

## **创造Promise实例：**

```javascript
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){	//由JS引擎提供，不用自己部署，就是不用自己声明
    resolve(value);
  } else {
    reject(error);
  }
});
```
Promise实例生成以后，可以用**then**方法分别指定**resolved**状态和**rejected**状态的回调函数。

## **一个简单的Promise对象实例：**

```javascript
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});
promise.then(function() {
  console.log('resolved.');
});
console.log('Hi!');
// Promise
// Hi!
// resolved
```
promise实例在被创建时就是立即执行，所以先输出Promise，而.then是promise执行完的回调，所以后输出resolved。

## **Promise实现多重异步操作：**

在声明的时候，Promise传递的参数函数会立即执行，因此Promise使用的正确姿势是在其外层再包裹一层函数。在只有一重的异步操作时，Promise似乎没什么优势，而在多重的异步实现中就大不一样了。下面是一个例子中，如果没有采用Promise,回调地狱是不可避免的，而使用Promise就可以完美的管理几个相互依赖的函数的顺序。
```javascript
//第一个异步任务
function run_a(){
    return new Promise(function(resolve, reject){
        //假设已经进行了异步操作，并且获得了数据
        resolve("step1");
    });
}
//第二个异步任务
function run_b(data_a){
    return new Promise(function(resolve, reject){
        //假设已经进行了异步操作，并且获得了数据
        console.log(data_a);
        resolve("step2");
    });
}
//第三个异步任务
function run_c(data_b){
    return new Promise(function(resolve, reject){
        //假设已经进行了异步操作，并且获得了数据
        console.log(data_b);
        resolve("step3");
    });
}

//连续调用
run_a().then(function(data){
    return run_b(data);
}).then(function(data){
    return run_c(data);
}).then(function(data){
    console.log(data);
});

/*运行结果
  step1
  step2
  step3
*/
```

# 三、Promise.prototype.then()
其实在上面我们已经介绍了Promise的then方法，这是定义在Promise.prototype原型上的方法。then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。
```javascript
getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log("resolved: ", comments);
}, function funcB(err){
  console.log("rejected: ", err);
});
```
上面的例子中，getJSON是一个采用Promise封装的方法，第一个then返回一个新的Promise对象，第二个then只有等到这个新的Promise状态发生改变才会执行。

# 四、Promise.prototype.catch()
和then方法一样，catch也是Promise.prototype原型上的方法，用于指定发生错误时的回调函数。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTc5OTczMTczN119
-->